const bcrypt = require('bcryptjs');
const { GraphQLError } = require('graphql');
const prisma = require('../../config/prisma');
const { generateToken, protectResolver } = require('../../services/auth');

const usersResolvers = {
    Query: {
        getAllUsers: protectResolver(async () => {
            return prisma.user.findMany({
                // include: { posts: true } // Optionally include related posts
            });
        }),
        getUser: protectResolver(async (_, { uuid }) => {
            const user = await prisma.user.findUnique({
                where: { uuid },
                // include: { posts: true }
            });
            if (!user) {
                throw new GraphQLError('User not found', { extensions: { code: 'NOT_FOUND' } });
            }
            return user;
        }),
    },
    Mutation: {
        registerUser: async (_, { input }) => {
            const { name, email, password } = input;

            const existingUser = await prisma.user.findUnique({ where: { email } });
            if (existingUser) {
                throw new GraphQLError('User with this email already exists', {
                    extensions: { code: 'BAD_USER_INPUT', argumentName: 'email' },
                });
            }

            const hashedPassword = await bcrypt.hash(password, 12);

            try {
                const user = await prisma.user.create({
                    data: {
                        // uuid will be auto-generated by Prisma based on @default(uuid())
                        name,
                        email,
                        password: hashedPassword,
                    },
                });

                const token = generateToken({ uuid: user.uuid, email: user.email });
                // Return only non-sensitive fields for the user in the payload
                const userPayload = { uuid: user.uuid, name: user.name, email: user.email, createdAt: user.createdAt, updatedAt: user.updatedAt };
                return { token, user: userPayload };
            } catch (err) {
                // Prisma errors often have a code, e.g., P2002 for unique constraint violation
                if (err.code === 'P2002') {
                    throw new GraphQLError('Email already in use.', {
                        extensions: { code: 'BAD_USER_INPUT', field: "email" },
                    });
                }
                console.error("Registration error:", err);
                throw new GraphQLError('Could not register user.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });
            }
        },
        loginUser: async (_, { email, password }) => {
            const user = await prisma.user.findUnique({ where: { email } });
            if (!user) {
                throw new GraphQLError('Invalid email or password.', { extensions: { code: 'UNAUTHENTICATED' } });
            }

            const isValidPassword = await bcrypt.compare(password, user.password);
            if (!isValidPassword) {
                throw new GraphQLError('Invalid email or password.', { extensions: { code: 'UNAUTHENTICATED' } });
            }

            const token = generateToken({ uuid: user.uuid, email: user.email });
            // Return only non-sensitive fields for the user in the payload
            const userPayload = { uuid: user.uuid, name: user.name, email: user.email, createdAt: user.createdAt, updatedAt: user.updatedAt };
            return { token, user: userPayload };
        },
        updateUser: protectResolver(async (_, { uuid, input }, context) => {
            if (context.user.id !== uuid) {
                throw new GraphQLError('Not authorized to update this user.', { extensions: { code: 'FORBIDDEN' } });
            }

            const { name, email } = input;
            const dataToUpdate = {};
            if (name) dataToUpdate.name = name;
            if (email) dataToUpdate.email = email; // Prisma will throw error if email is taken due to @unique

            if (Object.keys(dataToUpdate).length === 0) {
                throw new GraphQLError('No update information provided.', { extensions: { code: 'BAD_USER_INPUT' } });
            }

            try {
                const updatedUser = await prisma.user.update({
                    where: { uuid },
                    data: dataToUpdate,
                });
                return updatedUser;
            } catch (err) {
                if (err.code === 'P2025') { // Record to update not found
                    throw new GraphQLError('User not found.', { extensions: { code: 'NOT_FOUND' } });
                }
                if (err.code === 'P2002' && err.meta?.target?.includes('email')) { // Unique constraint failed for email
                    throw new GraphQLError('Email already in use by another account.', {
                        extensions: { code: 'BAD_USER_INPUT', argumentName: 'email' },
                    });
                }
                console.error("Update user error:", err);
                throw new GraphQLError('Could not update user.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });
            }
        }),
        deleteUser: protectResolver(async (_, { uuid }, context) => {
            if (context.user.id !== uuid /* && context.user.role !== 'ADMIN' */) { // Add admin check if needed
                throw new GraphQLError('Not authorized to delete this user.', { extensions: { code: 'FORBIDDEN' } });
            }
            try {
                await prisma.user.delete({ where: { uuid } }); // `onDelete: Cascade` in schema handles posts
                return `User with UUID ${uuid} successfully deleted.`;
            } catch (err) {
                if (err.code === 'P2025') { // Record to delete not found
                    throw new GraphQLError('User not found.', { extensions: { code: 'NOT_FOUND' } });
                }
                console.error("Delete user error:", err);
                throw new GraphQLError('Could not delete user.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });
            }
        }),
    },
};

module.exports = usersResolvers;